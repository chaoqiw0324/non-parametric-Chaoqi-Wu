---
title: "odds ratio test"
author: "Daniel Malinsky and Chaoqi Wu"
date: "2023-09-15"
output:
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '2'
    code_folding: hide
  pdf_document:
    toc: yes
    toc_depth: '2'
  word_document:
    toc: yes
    toc_depth: '2'
header-includes:
- \usepackage{fancyhdr}
- \usepackage{lipsum}
- \pagestyle{fancy}
- \fancyhead[R]{\thepage}
- \fancypagestyle{plain}{\pagestyle{fancy}}
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(MXM)
library(rje)
library(tidyverse)
library(arules)
library(caret)
library(BB)
library(ggplot2)
library(ranger)
library(randomForest)
library(lubridate)
library(patchwork)
```

# Estimation Function

```{r warning=FALSE,message =FALSE,fig.dim = c(10,8)}
psi.hat_linear <- function(Y, A, L=c(), subset = NULL, out.bin = TRUE, exp.bin = FALSE, exp.scalar = FALSE, root = "uni"){
  ## Function: estimate the odds ratio parameter psi
  ## Input: 1. An outcome nuisance model, onm = f(Y|L,A=0)
  ##        2. An exposure nuisance model, enm = g(A|Y=0,L)
  ## Output: A real number (vector) psi.hat, an estimate of the conditional odds ratio parameter psi
  
  ## Todo: generalize estimating eq to arbitrary dimensions
  
  if(length(L)==0){
    fm_out <- "Y ~ A"
    fm_out <- as.formula(fm_out)
    fm_exp <- "A ~ Y"
    fm_exp <- as.formula(fm_exp) ## for cases where conditioning set is empty
    dat <- data.frame(Y,A)
  }else{
    covnames <- colnames(L)
    fm_out <- paste0("Y ~ A + ", paste(covnames, collapse = "+"))
    fm_out <- as.formula(fm_out)
    fm_exp <- paste0("A ~ Y + ", paste(covnames, collapse = "+"))
    fm_exp <- as.formula(fm_exp)
    dat <- data.frame(Y,A,L)
  }
  
  
  if(!is.null(subset)) Y <- Y[subset]
  if(!is.null(subset)) A <- A[subset,]
  if(!is.null(subset)) L <- L[subset,]
  #temp
  
  
  refA <- 0 
  refY <- 0
    
    if(out.bin && exp.bin){
      h.dag <- 0.25 ## probability f.dag(Y|L) = g.dag(A|L) = 0.5, i.e., Y ~ A ~ Bernoulli(0.5)
      dat1 <- dat
      dat2 <- dat
      
      outcome <- glm(fm_out,family=binomial,data = dat)
      dat1$A <- 0 ## setting A=0
      onm <- predict.glm(outcome, newdata=dat1,type="response") # may cause warning: prediction from a rank-deficient fit may be misleading
      onm[Y==0] <- 1-onm[Y==0]
    
      exposure <- glm(fm_exp, family = binomial,data = dat)
      dat2$Y <- 0 ## setting Y=0
      enm <- predict.glm(exposure, newdata=dat2,type="response") # may cause warning: prediction from a rank-deficient fit may be misleading
      enm[A==0] <- 1-enm[A==0]
    
      d.diff <- (-1)^(Y+A) ## Eric's suggestion, for Y,A binary
    
      # build estimate function
      estimating_function <- function(psi){
        estf = d.diff*h.dag / (exp(psi*Y*A)*onm*enm)
      return(estf) 
      }
  
      estimating_equation <- function(psi){
        estf = estimating_function(psi)         
        este = sum(estf)                       
        return(este)
      }
      if (root == "uni") {
        U <- function(psi,onm,enm,d.diff){ sum( d.diff*h.dag / (exp(psi*Y*A)*onm*enm) ) }
        est <- uniroot(U, interval = c(-3.0, 3.0), extendInt = "yes", tol = 0.001,maxiter=1000, onm = onm, enm = enm, d.diff=d.diff)
        res <-  est$root
      }else if(root == "multi"){
        proc <- rootSolve::multiroot(f = estimating_equation,     
                                  start = c(-3.0))
        res <- proc$root
      }
        
        # Baking the bread (approximate derivative)
        deriv <- numDeriv::jacobian(func = estimating_equation,   
                                x = res)              
        bread <- -1*deriv / n
        
        # Cooking the filling (matrix algebra)
        outerprod <- sum(estimating_function(res) * estimating_function(res)) 
        # alternative code using matrix algebra
        # outerprod <- t(estimating_function(mu_root)) %*% estimating_function(mu_root) 
        filling <- outerprod/n 
    
        # Assembling the sandwich (matrix algebra)
        sandwich <- (bread^-1) %*% filling %*% (bread^-1)
        se <- as.numeric(sqrt(sandwich / n))
        
    result <- c(res,se)
    return(result)
    }
  
    if(!out.bin){ 
      outcome <- glm(fm_out, family = gaussian,data = dat)
    } else outcome <- glm(fm_out, family = binomial,data = dat)
    dat1 <- dat
    dat1$A <- 0 ## setting A=0
    onm <- predict.glm(outcome, newdata=dat1,type="response")
    onm[Y==0] <- 1-onm[Y==0]
  
    if(!exp.bin){
      exposure <- glm(fm_exp, family = gaussian,data = dat)
    } else exposure <- glm(fm_exp, family = binomial,data = dat)
    dat2 <- dat
    dat2$Y <- 0 ## setting Y=0
    enm <- predict.glm(exposure, newdata=dat2,type="response")
    enm[A==0] <- 1-enm[A==0]
  
  
    #U <- function(psi,onm,enm){ sum( (Y - onm)*(A - enm)*exp(-psi*Y*A) )}
    #est <- uniroot(U, interval = c(-3.0, 3.0), extendInt = "yes", tol = 0.001, onm = onm, enm = enm)
    #return(est$root)
  
    # build estimate function
    estimating_function <- function(psi){
      estf = (Y - onm)*(A - enm)*exp(-psi*Y*A) 
    return(estf) 
    }

    estimating_equation <- function(psi){
      estf = estimating_function(psi)         
      este = sum(estf)                       
      return(este)
    }   
    
    if (root == "uni") {
      U <- function(psi){ sum( (Y - onm)*(A - enm)*exp(-psi*Y*A) )}
      par.init <- c(0)
      sol <- BBsolve(par=par.init, fn=U, quiet=TRUE) 
      res <- sol$par
      }else if(root == "multi"){
        proc <- rootSolve::multiroot(f = estimating_equation,     
                                  start = c(-3.0))
        res <- proc$root
      }

    # Baking the bread (approximate derivative)
    deriv <- numDeriv::jacobian(func = estimating_equation,   
                            x = res)              
    bread <- -1*deriv / n
    
    # Cooking the filling (matrix algebra)
    outerprod <- sum(estimating_function(res) * estimating_function(res)) 
    # alternative code using matrix algebra
    # outerprod <- t(estimating_function(mu_root)) %*% estimating_function(mu_root) 
    filling <- outerprod/n 

    # Assembling the sandwich (matrix algebra)
    sandwich <- (bread^-1) %*% filling %*% (bread^-1)
    se <- as.numeric(sqrt(sandwich / n))
    
    result <- c(res,se)
    return(result)

}
```

```{r warning=FALSE,message =FALSE,fig.dim = c(10,8)}
psi.hat_rf <- function(Y, A, L=c(), subset = NULL, out.bin = TRUE, exp.bin = FALSE, exp.scalar = FALSE, root = "uni"){
  ## Function: estimate the odds ratio parameter psi
  ## Input: 1. An outcome nuisance model, onm = f(Y|L,A=0)
  ##        2. An exposure nuisance model, enm = g(A|Y=0,L)
  ## Output: A real number (vector) psi.hat_ranger, an estimate of the conditional odds ratio parameter psi
  
  ## Todo: generalize estimating eq to arbitrary dimensions
  
  if (length(L) == 0) {
    fm_out <- "Y ~ A"
    fm_out <- as.formula(fm_out)
    fm_exp <- "A ~ Y"
    fm_exp <- as.formula(fm_exp) ## for cases where conditioning set is empty
    dat <- data.frame(Y,A)
  }else{
    covnames <- colnames(L)
    fm_out <- paste0("Y ~ A + ", paste(covnames, collapse = "+"))
    fm_out <- as.formula(fm_out)
    fm_exp <- paste0("A ~ Y + ", paste(covnames, collapse = "+"))
    fm_exp <- as.formula(fm_exp)
    dat <- data.frame(Y,A,L)
    
  }
  
  
  if (!is.null(subset)) Y <- Y[subset]
  if (!is.null(subset)) A <- A[subset,]
  if (!is.null(subset)) L <- L[subset,]
  #temp
  
  
  refA <- 0 
  refY <- 0
  # parameter for ranger
  mtry_up <- length(L)+1
  mtry <- round(sqrt(mtry_up))
    
    if(out.bin && exp.bin){
      h.dag <- 0.25 ## probability f.dag(Y|L) = g.dag(A|L) = 0.5, i.e., Y ~ A ~ Bernoulli(0.5)
      dat1 <- dat
      dat2 <- dat
      
      # outcome 
      ## outcome tune parameter 

      dat_out <- dat
      dat_out$Y <- factor(dat_out$Y,levels = c(0,1),labels = c("neg","pos"))
      
      outcome <- ranger(fm_out, 
                        num.trees = 100,
                        mtry = mtry,
                        min.node.size = 25,
                        data = dat_out,
                        probability = TRUE)
      dat1$A <- 0 ## setting A=0
      onm <- predict(outcome, data=dat1,type="response")$prediction
      # onm <- predict(outcome, data=dat1,type="prob")[,2]
      onm[Y==0] <- 1-onm[Y==0]
      
      # exposure 
      # exposure tune parameter

      dat_exp <- dat
      dat_exp$A <- factor(dat_exp$A,levels = c(0,1),labels = c("neg","pos"))

      exposure <- ranger(fm_exp, 
                         num.trees = 100,
                         mtry = mtry,
                         min.node.size = 25,
                         data = dat,
                         probability = TRUE)
      dat2$Y <- 0 ## setting Y=0
      enm <- predict(exposure, data=dat2,type="response")$predictions
      # enm <- predict(exposure_train, data=dat2,type="prob")[,2]
      enm[A==0] <- 1-enm[A==0]
    
    
      d.diff <- (-1)^(Y+A) ## Eric's suggestion, for Y,A binary
      # build estimate function
      estimating_function <- function(psi){
        estf = d.diff*h.dag / (exp(psi*Y*A)*onm*enm)
      return(estf) 
      }
  
      estimating_equation <- function(psi){
        estf = estimating_function(psi)         
        este = sum(estf)                       
        return(este)
      }
      if (root == "uni") {
        U <- function(psi,onm,enm,d.diff){ sum( d.diff*h.dag / (exp(psi*Y*A)*onm*enm) ) }
        est <- uniroot(U, interval = c(-3.0, 3.0), extendInt = "yes", tol = 0.001,maxiter=1000, onm = onm, enm = enm, d.diff=d.diff)
        res <-  est$root
      }else if(root == "multi"){
        proc <- rootSolve::multiroot(f = estimating_equation,     
                                  start = c(-3.0))
        res <- proc$root
      }
        
        # Baking the bread (approximate derivative)
        deriv <- numDeriv::jacobian(func = estimating_equation,   
                                x = res)              
        bread <- -1*deriv / n
        
        # Cooking the filling (matrix algebra)
        outerprod <- sum(estimating_function(res) * estimating_function(res)) 
        # alternative code using matrix algebra
        # outerprod <- t(estimating_function(mu_root)) %*% estimating_function(mu_root) 
        filling <- outerprod/n 
    
        # Assembling the sandwich (matrix algebra)
        sandwich <- (bread^-1) %*% filling %*% (bread^-1)
        se <- as.numeric(sqrt(sandwich / n))
        
    result <- c(res,se)
    return(result)
    }
  
  
  
  
    # at least one variable is non-bianry  
  
    if(!out.bin){

      
      outcome <- ranger(fm_out, 
                        num.trees = 1000,
                        min.node.size = 25,
                        mtry = mtry,
                        data = dat)
      dat1 <- dat
      dat1$A <- 0 
      # onm <- predict(outcome, data=dat1,type="response")$prediction
      onm <- predict(outcome, data=dat1,type="response")$predictions
      onm[Y==0] <- 1-onm[Y==0]
    }else{
      dat1 <- dat
      dat_out <- dat
      dat_out$Y <- factor(dat_out$Y,levels = c(0,1),labels = c("neg","pos"))
      
      outcome <- ranger(fm_out, 
                        num.trees = 1000,
                        min.node.size = 25,
                        mtry = mtry,
                        data = dat_out,
                        probability = TRUE)
      dat1$A <- 0 ## setting A=0
      onm <- predict(outcome, data=dat1,type="response")$prediction
      # onm <- predict(outcome, data=dat1,type="prob")[,2]
      onm[Y==0] <- 1-onm[Y==0]
    }

  
    if(!exp.bin){

      exposure <- ranger(fm_exp, 
                          num.trees = 1000,
                         min.node.size = 25,
                          mtry = mtry,
                          data = dat)
      dat2 <- dat
      dat2$Y <- 0 ## setting Y=0
      # enm <- predict(exposure, data=dat2,type="response")$predictions
      enm <- predict(exposure, data=dat2,type="response")$predictions
      enm[A==0] <- 1-enm[A==0]
    }else{
      dat_exp <- dat
      dat_exp$A <- factor(dat_exp$A,levels = c(0,1),labels = c("neg","pos"))

      exposure <- ranger(fm_exp, 
                         num.trees = 1000,
                         min.node.size = 25,
                         mtry = mtry,
                         data = dat,
                         probability = TRUE)
      dat2 <- dat
      dat2$Y <- 0 ## setting Y=0
      enm <- predict(exposure, data=dat2,type="response")$predictions
      # enm <- predict(exposure_train, data=dat2,type="prob")[,2]
      enm[A==0] <- 1-enm[A==0]
    }
  
    # build estimate function
    estimating_function <- function(psi){
      estf = (Y - onm)*(A - enm)*exp(-psi*Y*A) 
    return(estf) 
    }

    estimating_equation <- function(psi){
      estf = estimating_function(psi)         
      este = sum(estf)                       
      return(este)
    }   
    
    if (root == "uni") {
      U <- function(psi){ sum( (Y - onm)*(A - enm)*exp(-psi*Y*A) )}
      par.init <- c(0)
      sol <- BBsolve(par=par.init, fn=U, quiet=TRUE) 
      res <- sol$par
      }else if(root == "multi"){
        proc <- rootSolve::multiroot(f = estimating_equation,     
                                  start = c(-3.0))
        res <- proc$root
      }

    # Baking the bread (approximate derivative)
    deriv <- numDeriv::jacobian(func = estimating_equation,   
                            x = res)              
    bread <- -1*deriv / n
    
    # Cooking the filling (matrix algebra)
    outerprod <- sum(estimating_function(res) * estimating_function(res)) 
    # alternative code using matrix algebra
    # outerprod <- t(estimating_function(mu_root)) %*% estimating_function(mu_root) 
    filling <- outerprod/n 

    # Assembling the sandwich (matrix algebra)
    sandwich <- (bread^-1) %*% filling %*% (bread^-1)
    se <- as.numeric(sqrt(sandwich / n))
    
    result <- c(res,se)
    return(result)

}
```

# Function Test

```{r warning=FALSE,message =FALSE,fig.dim = c(10,8)}
n <- 10000
nsample <- 1000
```

## (1) outcome: continuous, exposure: binary

### Linear Relationship

```{r warning=FALSE,message =FALSE,fig.dim = c(10,8)}
t1 <- Sys.time()
result_cb <- matrix(ncol = 3,nrow = nsample)
result_cb_L <- matrix(ncol = 3,nrow = nsample)
result_cb_rf <- matrix(ncol = 3,nrow = nsample)
result_cb_rf_L <- matrix(ncol = 3,nrow = nsample)
for (i in 1:nsample) {
  L.true <- rbinom(n,1,0.5) ## L.true <- cbind(L.true,rep(0,N))
  Z <- 0.5 + 0.5*L.true
  pr <- 1/(1+exp(-Z))
  Y.true <- 2*Z - rnorm(n)
  A.true <- rbinom(n,1,pr)
  dat <- tibble(
    L = L.true,
    Y = Y.true,
    A = A.true
  )
  # summary(glm(Y~A+L,data=dat))
  # summary(glm(Y~A,data=dat))
  L <- tibble(L = dat$L)
  # linear
  res_cb <- psi.hat_linear(Y=dat$Y,A=dat$A,L=c(), subset = NULL, out.bin = FALSE, exp.bin = TRUE, exp.scalar = TRUE)
  result_cb[i,1] <- exp(res_cb[1])
  result_cb[i,2] <- exp(res_cb[1]-1.96*res_cb[2])
  result_cb[i,3] <- exp(res_cb[1]+1.96*res_cb[2])
  res_cb_L <- psi.hat_linear(dat$Y,dat$A,L, subset = NULL, out.bin = FALSE, exp.bin = TRUE, exp.scalar = TRUE)
  result_cb_L[i,1] <- exp(res_cb_L[1])
  result_cb_L[i,2] <- exp(res_cb_L[1]-1.96*res_cb_L[2])
  result_cb_L[i,3] <- exp(res_cb_L[1]+1.96*res_cb_L[2])
  # random forest
  res_cb_rf <- psi.hat_rf(Y=dat$Y,A=dat$A,L=c(), subset = NULL, out.bin = FALSE, exp.bin = TRUE, exp.scalar = TRUE)
  result_cb_rf[i,1] <- exp(res_cb_rf[1])
  result_cb_rf[i,2] <- exp(res_cb_rf[1]-1.96*res_cb_rf[2])
  result_cb_rf[i,3] <- exp(res_cb_rf[1]+1.96*res_cb_rf[2])
  res_cb_rf_L <- psi.hat_rf(dat$Y,dat$A,L, subset = NULL, out.bin = FALSE, exp.bin = TRUE, exp.scalar = TRUE)
  result_cb_rf_L[i,1] <- exp(res_cb_rf_L[1])
  result_cb_rf_L[i,2] <- exp(res_cb_rf_L[1]-1.96*res_cb_rf_L[2])
  result_cb_rf_L[i,3] <- exp(res_cb_rf_L[1]+1.96*res_cb_rf_L[2])
}
t2 <- Sys.time()
df_cb <- as.data.frame(result_cb)
colnames(df_cb) <- c("point","ci_low","ci_high")
df_cb <- df_cb %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

df_cb_L <- as.data.frame(result_cb_L)
colnames(df_cb_L) <- c("point","ci_low","ci_high")
df_cb_L <- df_cb_L %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

table_cb <- tibble(
  noL <- c(sum(df_cb$contain)/nrow(df_cb)),
  L <- c(sum(df_cb_L$contain)/nrow(df_cb_L))
  )

knitr::kable(table_cb,
             format = "pipe",
             digits = 3,
             col.names = c("Coverage Rate","Coverage Rate Condition on L"),
             caption = "Result For Continuous Outcome to Binary Exposure(GLM)"
             ) 

df_cb_rf <- as.data.frame(result_cb_rf)
colnames(df_cb_rf) <- c("point","ci_low","ci_high")
df_cb_rf <- df_cb_rf %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

df_cb_rf_L <- as.data.frame(result_cb_rf_L)
colnames(df_cb_rf_L) <- c("point","ci_low","ci_high")
df_cb_rf_L <- df_cb_rf_L %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

table_cb_rf <- tibble(
  noL <- c(sum(df_cb_rf$contain)/nrow(df_cb_rf)),
  L <- c(sum(df_cb_rf_L$contain)/nrow(df_cb_rf_L))
  )

knitr::kable(table_cb_rf,
             format = "pipe",
             digits = 3,
             col.names = c("Coverage Rate","Coverage Rate Condition on L"),
             caption = "Result For Continuous Outcome to Binary Exposure(Random Forest)"
             ) 

p1_1_1 <- df_cb %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (GLM without L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))

p1_1_2 <- df_cb_L %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (GLM with L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))   

p1_1_3 <- df_cb_rf %>% 
  filter(point<2) %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (Random Forest without L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))    

p1_1_4 <- df_cb_rf_L %>%
  filter(point<2) %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (Random Forest with L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))    

(p1_1_1+p1_1_2)/(p1_1_3+p1_1_4)
```

### Non-linear Relationship
```{r warning=FALSE,message =FALSE,fig.dim = c(10,8)}
result_cb2 <- matrix(ncol = 3,nrow = nsample)
result_cb_L2 <- matrix(ncol = 3,nrow = nsample)
result_cb_rf2 <- matrix(ncol = 3,nrow = nsample)
result_cb_rf_L2 <- matrix(ncol = 3,nrow = nsample)
for (i in 1:nsample) {
  L1 <- runif(n,0,1)
  L2 <- runif(n,0,1)
  L3 <- runif(n,0,1)
  L_vec <- tibble(
    L1 = L1,
    L2 = L2,
    L3 = L3)
  L_vec <- L_vec %>% 
    mutate(
      length = (L1^2 + L2^2 + L3^2)^0.5,
      L1 = L1/length,
      L2 = L2/length,
      L3 = L3/length
      ) %>% 
    select(-length)
  L.true <- 2*L1 + L2^2 + L1*L3
  Z <- 0.5 + 0.5*L.true
  pr <- 1/(1+3.5*exp(-Z)) # control the probability close to 0.5
  Y.true <- 2*Z - rnorm(n)
  A.true <- rbinom(n,1,pr)
  dat <- tibble(
    Y = Y.true,
    A = A.true
  ) %>% cbind(L_vec)
  # summary(glm(Y~A+L,data=dat))
  # summary(glm(Y~A,data=dat))
  L <- tibble(L = dat$L)
  # linear
  res_cb <- psi.hat_linear(Y=dat$Y,A=dat$A,L=c(), subset = NULL, out.bin = FALSE, exp.bin = TRUE, exp.scalar = TRUE)
  result_cb2[i,1] <- exp(res_cb[1])
  result_cb2[i,2] <- exp(res_cb[1]-1.96*res_cb[2])
  result_cb2[i,3] <- exp(res_cb[1]+1.96*res_cb[2])
  res_cb_L <- psi.hat_linear(dat$Y,dat$A,L, subset = NULL, out.bin = FALSE, exp.bin = TRUE, exp.scalar = TRUE)
  result_cb_L2[i,1] <- exp(res_cb_L[1])
  result_cb_L2[i,2] <- exp(res_cb_L[1]-1.96*res_cb_L[2])
  result_cb_L2[i,3] <- exp(res_cb_L[1]+1.96*res_cb_L[2])
  # random forest
  res_cb_rf <- psi.hat_rf(Y=dat$Y,A=dat$A,L=c(), subset = NULL, out.bin = FALSE, exp.bin = TRUE, exp.scalar = TRUE)
  result_cb_rf2[i,1] <- exp(res_cb_rf[1])
  result_cb_rf2[i,2] <- exp(res_cb_rf[1]-1.96*res_cb_rf[2])
  result_cb_rf2[i,3] <- exp(res_cb_rf[1]+1.96*res_cb_rf[2])
  res_cb_rf_L <- psi.hat_rf(dat$Y,dat$A,L_vec, subset = NULL, out.bin = FALSE, exp.bin = TRUE, exp.scalar = TRUE)
  result_cb_rf_L2[i,1] <- exp(res_cb_rf_L[1])
  result_cb_rf_L2[i,2] <- exp(res_cb_rf_L[1]-1.96*res_cb_rf_L[2])
  result_cb_rf_L2[i,3] <- exp(res_cb_rf_L[1]+1.96*res_cb_rf_L[2])
}
t2 <- Sys.time()
df_cb2 <- as.data.frame(result_cb2)
colnames(df_cb2) <- c("point","ci_low","ci_high")
df_cb2 <- df_cb2 %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

df_cb_L2 <- as.data.frame(result_cb_L2)
colnames(df_cb_L2) <- c("point","ci_low","ci_high")
df_cb_L2 <- df_cb_L2 %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

table_cb2 <- tibble(
  noL <- c(sum(df_cb2$contain)/nrow(df_cb2)),
  L <- c(sum(df_cb_L2$contain)/nrow(df_cb_L2))
  )

knitr::kable(table_cb2,
             format = "pipe",
             digits = 3,
             col.names = c("Coverage Rate","Coverage Rate Condition on L"),
             caption = "Result For Continuous Outcome to Binary Exposure(GLM)"
             ) 

df_cb_rf2 <- as.data.frame(result_cb_rf2)
colnames(df_cb_rf2) <- c("point","ci_low","ci_high")
df_cb_rf2 <- df_cb_rf2 %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

df_cb_rf_L2 <- as.data.frame(result_cb_rf_L2)
colnames(df_cb_rf_L2) <- c("point","ci_low","ci_high")
df_cb_rf_L2 <- df_cb_rf_L2 %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

table_cb_rf2 <- tibble(
  noL <- c(sum(df_cb_rf2$contain)/nrow(df_cb_rf2)),
  L <- c(sum(df_cb_rf_L2$contain)/nrow(df_cb_rf_L2))
  )

knitr::kable(table_cb_rf2,
             format = "pipe",
             digits = 3,
             col.names = c("Coverage Rate","Coverage Rate Condition on L"),
             caption = "Result For Continuous Outcome to Binary Exposure(Random Forest)"
             ) 


p1_2_1 <- df_cb2 %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (GLM without L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))

p1_2_2 <- df_cb_L2 %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (GLM with L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))   

p1_2_3 <- df_cb_rf2 %>% 
  filter(point<2) %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (Random Forest without L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))    

p1_2_4 <- df_cb_rf_L2 %>%
  filter(point<2) %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (Random Forest with L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))   

(p1_2_1+p1_2_2)/(p1_2_3+p1_2_4)
```


## (2) outcome: continous, exposure: continous

### Linear Relationship

```{r warning=FALSE,message =FALSE,fig.dim = c(10,8)}
t1 <- Sys.time()
result_cc <- matrix(ncol = 3,nrow = nsample)
result_cc_L <- matrix(ncol = 3,nrow = nsample)
result_cc_rf <- matrix(ncol = 3,nrow = nsample)
result_cc_rf_L <- matrix(ncol = 3,nrow = nsample)
for (i in 1:nsample) {
  L.true <- rnorm(n,0,1) ## L.true <- cbind(L.true,rep(0,N))
  Z <- 0.5 + 0.5*L.true
  Y.true <- 5*Z + rnorm(n)
  A.true <- -4*Z + rnorm(n)
  dat <- tibble(
    L = L.true,
    Y = Y.true,
    A = A.true
  )
  # summary(glm(Y~A+L,data=dat))
  # summary(glm(Y~A,data=dat))
  L <- tibble(L= dat$L)

  res_cc <- psi.hat_linear(Y=dat$Y,A=dat$A,L=c(), subset = NULL, out.bin = FALSE, exp.bin = FALSE, exp.scalar = TRUE)
  result_cc[i,1] <- exp(res_cc[1])
  result_cc[i,2] <- exp(res_cc[1]-1.96*res_cc[2])
  result_cc[i,3] <- exp(res_cc[1]+1.96*res_cc[2])
  res_cc_L <- psi.hat_linear(dat$Y,dat$A,L, subset = NULL, out.bin = FALSE, exp.bin = FALSE, exp.scalar = TRUE)
  result_cc_L[i,1] <- exp(res_cc_L[1])
  result_cc_L[i,2] <- exp(res_cc_L[1]-1.96*res_cc_L[2])
  result_cc_L[i,3] <- exp(res_cc_L[1]+1.96*res_cc_L[2])
  #random forest
  res_cc_rf <- psi.hat_rf(Y=dat$Y,A=dat$A,L=c(), subset = NULL, out.bin = FALSE, exp.bin = FALSE, exp.scalar = TRUE)
  result_cc_rf[i,1] <- exp(res_cc_rf[1])
  result_cc_rf[i,2] <- exp(res_cc_rf[1]-1.96*res_cc_rf[2])
  result_cc_rf[i,3] <- exp(res_cc_rf[1]+1.96*res_cc_rf[2])
  res_cc_rf_L <- psi.hat_rf(dat$Y,dat$A,L, subset = NULL, out.bin = FALSE, exp.bin = FALSE, exp.scalar = TRUE)
  result_cc_rf_L[i,1] <- exp(res_cc_rf_L[1])
  result_cc_rf_L[i,2] <- exp(res_cc_rf_L[1]-1.96*res_cc_rf_L[2])
  result_cc_rf_L[i,3] <- exp(res_cc_rf_L[1]+1.96*res_cc_rf_L[2])
}
t2 <- Sys.time()

df_cc <- as.data.frame(result_cc)
colnames(df_cc) <- c("point","ci_low","ci_high")
df_cc <- df_cc %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

df_cc_L <- as.data.frame(result_cc_L)
colnames(df_cc_L) <- c("point","ci_low","ci_high")
df_cc_L <- df_cc_L %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

table_cc <- tibble(
  noL <- c(sum(df_cc$contain)/nrow(df_cc)),
  L <- c(sum(df_cc_L$contain)/nrow(df_cc_L))
  )

knitr::kable(table_cc,
             format = "pipe",
             digits = 3,
             col.names = c("Coverage Rate","Coverage Rate Condition on L"),
             caption = "Result For Continuous Outcome to Continuous Exposure(GLM)"
             ) 

df_cc_rf <- as.data.frame(result_cc_rf)
colnames(df_cc_rf) <- c("point","ci_low","ci_high")
df_cc_rf <- df_cc_rf %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

df_cc_rf_L <- as.data.frame(result_cc_rf_L)
colnames(df_cc_rf_L) <- c("point","ci_low","ci_high")
df_cc_rf_L <- df_cc_rf_L %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

table_cc_rf <- tibble(
  noL <- c(sum(df_cc_rf$contain)/nrow(df_cc_rf)),
  L <- c(sum(df_cc_rf_L$contain)/nrow(df_cc_rf_L))
  )

knitr::kable(table_cc_rf,
             format = "pipe",
             digits = 3,
             col.names = c("Coverage Rate","Coverage Rate Condition on L"),
             caption = "Result For Continuous Outcome to Continuous Exposure(Random Forest)"
             ) 

p2_1_1 <- df_cc %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (GLM without L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))

p2_1_2 <- df_cc_L %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (GLM with L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))   

p2_1_3 <- df_cc_rf %>% 
  filter(point<2) %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (Random Forest without L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))    

p2_1_4 <- df_cc_rf_L %>%
  filter(point<2) %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (Random Forest with L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))   

(p2_1_1+p2_1_2)/(p2_1_3+p2_1_4)
```

### Non-linear Relationship

```{r warning=FALSE,message =FALSE,fig.dim = c(10,8)}
t1 <- Sys.time()
result_cc2 <- matrix(ncol = 3,nrow = nsample)
result_cc_L2 <- matrix(ncol = 3,nrow = nsample)
result_cc_rf2 <- matrix(ncol = 3,nrow = nsample)
result_cc_rf_L2 <- matrix(ncol = 3,nrow = nsample)
for (i in 1:nsample) {
  L1 <- runif(n,0,1)
  L2 <- runif(n,0,1)
  L3 <- runif(n,0,1)
  L_vec <- tibble(
    L1 = L1,
    L2 = L2,
    L3 = L3)
  L_vec <- L_vec %>% 
    mutate(
      length = (L1^2 + L2^2 + L3^2)^0.5,
      L1 = L1/length,
      L2 = L2/length,
      L3 = L3/length
      ) %>% 
    select(-length)
  L.true <- 2*L1 + L2^2 + L1*L3
  Z <- 0.5 + 0.5*L.true
  Y.true <- 5*Z + rnorm(n)
  A.true <- -4*Z + rnorm(n)
  dat <- tibble(
    Y = Y.true,
    A = A.true
  ) %>% cbind(L_vec)
  # summary(glm(Y~A+L,data=dat))
  # summary(glm(Y~A,data=dat))
  L <- tibble(L= dat$L)

  res_cc <- psi.hat_linear(Y=dat$Y,A=dat$A,L=c(), subset = NULL, out.bin = FALSE, exp.bin = FALSE, exp.scalar = TRUE)
  result_cc2[i,1] <- exp(res_cc[1])
  result_cc2[i,2] <- exp(res_cc[1]-1.96*res_cc[2])
  result_cc2[i,3] <- exp(res_cc[1]+1.96*res_cc[2])
  res_cc_L <- psi.hat_linear(dat$Y,dat$A,L, subset = NULL, out.bin = FALSE, exp.bin = FALSE, exp.scalar = TRUE)
  result_cc_L2[i,1] <- exp(res_cc_L[1])
  result_cc_L2[i,2] <- exp(res_cc_L[1]-1.96*res_cc_L[2])
  result_cc_L2[i,3] <- exp(res_cc_L[1]+1.96*res_cc_L[2])
  #random forest
  res_cc_rf <- psi.hat_rf(Y=dat$Y,A=dat$A,L=c(), subset = NULL, out.bin = FALSE, exp.bin = FALSE, exp.scalar = TRUE)
  result_cc_rf2[i,1] <- exp(res_cc_rf[1])
  result_cc_rf2[i,2] <- exp(res_cc_rf[1]-1.96*res_cc_rf[2])
  result_cc_rf2[i,3] <- exp(res_cc_rf[1]+1.96*res_cc_rf[2])
  res_cc_rf_L <- psi.hat_rf(dat$Y,dat$A,L_vec, subset = NULL, out.bin = FALSE, exp.bin = FALSE, exp.scalar = TRUE)
  result_cc_rf_L2[i,1] <- exp(res_cc_rf_L[1])
  result_cc_rf_L2[i,2] <- exp(res_cc_rf_L[1]-1.96*res_cc_rf_L[2])
  result_cc_rf_L2[i,3] <- exp(res_cc_rf_L[1]+1.96*res_cc_rf_L[2])
}
t2 <- Sys.time()

df_cc2 <- as.data.frame(result_cc2)
colnames(df_cc2) <- c("point","ci_low","ci_high")
df_cc2 <- df_cc2 %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

df_cc_L2 <- as.data.frame(result_cc_L2)
colnames(df_cc_L2) <- c("point","ci_low","ci_high")
df_cc_L2 <- df_cc_L2 %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

table_cc2 <- tibble(
  noL <- c(sum(df_cc2$contain)/nrow(df_cc2)),
  L <- c(sum(df_cc_L2$contain)/nrow(df_cc_L2))
  )

knitr::kable(table_cc2,
             format = "pipe",
             digits = 3,
             col.names = c("Coverage Rate","Coverage Rate Condition on L"),
             caption = "Result For Continuous Outcome to Continuous Exposure(GLM)"
             ) 

df_cc_rf2 <- as.data.frame(result_cc_rf2)
colnames(df_cc_rf2) <- c("point","ci_low","ci_high")
df_cc_rf2 <- df_cc_rf2 %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

df_cc_rf_L2 <- as.data.frame(result_cc_rf_L2)
colnames(df_cc_rf_L2) <- c("point","ci_low","ci_high")
df_cc_rf_L2 <- df_cc_rf_L2 %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

table_cc_rf2 <- tibble(
  noL <- c(sum(df_cc_rf2$contain)/nrow(df_cc_rf2)),
  L <- c(sum(df_cc_rf_L2$contain)/nrow(df_cc_rf_L2))
  )

knitr::kable(table_cc_rf2,
             format = "pipe",
             digits = 3,
             col.names = c("Coverage Rate","Coverage Rate Condition on L"),
             caption = "Result For Continuous Outcome to Continuous Exposure(Random Forest)"
             ) 

p2_2_1 <- df_cc2 %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (GLM without L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))

p2_2_2 <- df_cc_L2 %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (GLM with L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))   

p2_2_3 <- df_cc_rf2 %>% 
  filter(point<2) %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (Random Forest without L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))    

p2_2_4 <- df_cc_rf_L2 %>%
  filter(point<2) %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (Random Forest with L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5)) 

(p2_2_1+p2_2_2)/(p2_2_3+p2_2_4)
```

## (3) outcome: binary, exposure: continuous
```{r warning=FALSE,message =FALSE,fig.dim = c(10,8)}
# t1 <- Sys.time()
# result_bc <- matrix(ncol = 3,nrow = nsample)
# result_bc_L <- matrix(ncol = 3,nrow = nsample)
# for (i in 1:nsample) {
#   L.true <- rbinom(n,1,0.5) ## L.true <- bcind(L.true,rep(0,N))
#   Z <- 0.5 + 0.5*L.true
#   pr <- 1/(1+exp(-Z))
#   Y.true <- 2*Z - rnorm(n)
#   A.true <- rbinom(n,1,pr)
#   dat <- tibble(
#     L = L.true,
#     Y = Y.true,
#     A = A.true
#   )
#   # summary(glm(Y~A+L,data=dat))
#   # summary(glm(Y~A,data=dat))
#   L <- tibble(L = dat$L)
#   res_bc <- psi.hat_linear(Y=dat$Y,A=dat$A,L=c(), subset = NULL, out.bin = FALSE, exp.bin = TRUE, exp.scalar = TRUE)
#   result_bc[i,1] <- exp(res_bc[1])
#   result_bc[i,2] <- exp(res_bc[1]-1.96*res_bc[2])
#   result_bc[i,3] <- exp(res_bc[1]+1.96*res_bc[2])
#   res_bc_L <- psi.hat_linear(dat$Y,dat$A,L, subset = NULL, out.bin = FALSE, exp.bin = TRUE, exp.scalar = TRUE)
#   result_bc_L[i,1] <- exp(res_bc_L[1])
#   result_bc_L[i,2] <- exp(res_bc_L[1]-1.96*res_bc_L[2])
#   result_bc_L[i,3] <- exp(res_bc_L[1]+1.96*res_bc_L[2])
# }
# t2 <- Sys.time()
# 
# df_bc <- as.data.frame(result_bc)
# colnames(df_bc) <- c("point","ci_low","ci_high")
# df_bc <- df_bc %>%
#   mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))
# 
# df_bc_L <- as.data.frame(result_bc_L)
# colnames(df_bc_L) <- c("point","ci_low","ci_high")
# df_bc_L <- df_bc_L %>%
#   mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))
# 
# table_bc <- tibble(
#   noL <- c(sum(df_bc$contain)/nrow(df_bc)),
#   L <- c(sum(df_bc_L$contain)/nrow(df_bc_L))
#   )
# 
# knitr::kable(table_bc,
#              format = "pipe",
#              digits = 3,
#              col.names = c("Coverage Rate","Coverage Rate Condition on L"),
#              caption = "Result For Binary Outcome to Continous Exposure"
#              ) 
```

## (4) outcome: binary, exposure: binary

### Linear Relationship
```{r warning=FALSE,message =FALSE,fig.dim = c(10,8)}
t1 <- Sys.time()
result_bb <- matrix(ncol = 3,nrow = nsample)
result_bb_L <- matrix(ncol = 3,nrow = nsample)
result_bb_rf <- matrix(ncol = 3,nrow = nsample)
result_bb_rf_L <- matrix(ncol = 3,nrow = nsample)
for (i in 1:nsample) {
  L.true <- rbinom(n,1,0.5) ## L.true <- cbind(L.true,rep(0,N))
  Z <- 0.5 + 0.5*L.true
  pr <- 1/(0.5+exp(0.4*Z))
  Y.true <- rbinom(n,1,pr)
  A.true <- rbinom(n,1,pr)
  dat <- tibble(
    L = L.true,
    Y = Y.true,
    A = A.true
  )
  # summary(glm(Y~A+L,data=dat))
  # summary(glm(Y~A,data=dat))
  L <- tibble(L = dat$L)
  res_bb <- psi.hat_linear(Y=dat$Y,A=dat$A,L=c(), subset = NULL, out.bin = TRUE, exp.bin = TRUE, exp.scalar = TRUE)
  result_bb[i,1] <- exp(res_bb[1])
  result_bb[i,2] <- exp(res_bb[1]-1.96*res_bb[2])
  result_bb[i,3] <- exp(res_bb[1]+1.96*res_bb[2])
  res_bb_L <- psi.hat_linear(dat$Y,dat$A,L, subset = NULL, out.bin = TRUE, exp.bin = TRUE, exp.scalar = TRUE)
  result_bb_L[i,1] <- exp(res_bb_L[1])
  result_bb_L[i,2] <- exp(res_bb_L[1]-1.96*res_bb_L[2])
  result_bb_L[i,3] <- exp(res_bb_L[1]+1.96*res_bb_L[2])
  #random forest
  res_bb_rf <- psi.hat_rf(Y=dat$Y,A=dat$A,L=c(), subset = NULL, out.bin = TRUE, exp.bin = TRUE, exp.scalar = TRUE)
  result_bb_rf[i,1] <- exp(res_bb_rf[1])
  result_bb_rf[i,2] <- exp(res_bb_rf[1]-1.96*res_bb_rf[2])
  result_bb_rf[i,3] <- exp(res_bb_rf[1]+1.96*res_bb_rf[2])
  res_bb_rf_L <- psi.hat_rf(dat$Y,dat$A,L, subset = NULL, out.bin = TRUE, exp.bin = TRUE, exp.scalar = TRUE)
  result_bb_rf_L[i,1] <- exp(res_bb_rf_L[1])
  result_bb_rf_L[i,2] <- exp(res_bb_rf_L[1]-1.96*res_bb_rf_L[2])
  result_bb_rf_L[i,3] <- exp(res_bb_rf_L[1]+1.96*res_bb_rf_L[2])
}
t2 <- Sys.time()

df_bb <- as.data.frame(result_bb)
colnames(df_bb) <- c("point","ci_low","ci_high")
df_bb <- df_bb %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

df_bb_L <- as.data.frame(result_bb_L)
colnames(df_bb_L) <- c("point","ci_low","ci_high")
df_bb_L <- df_bb_L %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

table_bb <- tibble(
  noL <- c(sum(df_bb$contain)/nrow(df_bb)),
  L <- c(sum(df_bb_L$contain)/nrow(df_bb_L))
  )

knitr::kable(table_bb,
             format = "pipe",
             digits = 3,
             col.names = c("Coverage Rate","Coverage Rate Condition on L"),
             caption = "Result For Binary Outcome to Binary Exposure(GLM)"
             ) 

df_bb_rf <- as.data.frame(result_bb_rf)
colnames(df_bb_rf) <- c("point","ci_low","ci_high")
df_bb_rf <- df_bb_rf %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

df_bb_rf_L <- as.data.frame(result_bb_rf_L)
colnames(df_bb_rf_L) <- c("point","ci_low","ci_high")
df_bb_rf_L <- df_bb_rf_L %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

table_bb_rf <- tibble(
  noL <- c(sum(df_bb_rf$contain)/nrow(df_bb_rf)),
  L <- c(sum(df_bb_rf_L$contain)/nrow(df_bb_rf_L))
  )

knitr::kable(table_bb_rf,
             format = "pipe",
             digits = 3,
             col.names = c("Coverage Rate","Coverage Rate Condition on L"),
             caption = "Result For Binary Outcome to Binary Exposure(Random Forest)"
             ) 

p4_1_1 <- df_bb %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (GLM without L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))

p4_1_2 <- df_bb_L %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (GLM with L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))   

p4_1_3 <- df_bb_rf %>% 
  filter(point<2) %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (Random Forest without L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))    

p4_1_4 <- df_bb_rf_L %>%
  filter(point<2) %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (Random Forest with L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5)) 

(p4_1_1+p4_1_2)/(p4_1_3+p4_1_4)
```

### Non-linear Relationship

```{r warning=FALSE,message =FALSE,fig.dim = c(10,8)}
t1 <- Sys.time()
result_bb2 <- matrix(ncol = 3,nrow = nsample)
result_bb_L2 <- matrix(ncol = 3,nrow = nsample)
result_bb_rf2 <- matrix(ncol = 3,nrow = nsample)
result_bb_rf_L2 <- matrix(ncol = 3,nrow = nsample)
for (i in 1:nsample) {
  L1 <- runif(n,0,1)
  L2 <- runif(n,0,1)
  L3 <- runif(n,0,1)
  L_vec <- tibble(
    L1 = L1,
    L2 = L2,
    L3 = L3)
  L_vec <- L_vec %>%
    mutate(
      length = (L1^2 + L2^2 + L3^2)^0.5,
      L1 = L1/length,
      L2 = L2/length,
      L3 = L3/length
      ) %>%
    select(-length)
  L.true <- 2*L1 + L2^2 + L1*L3
  Z <- 0.5 + 0.5*L.true
  pr <- 1/(1+3.5*exp(-Z)) # control the probability close to 0.5
  Y.true <- rbinom(n,1,pr)
  A.true <- rbinom(n,1,pr)
  dat <- tibble(
    Y = Y.true,
    A = A.true
  ) %>% cbind(L_vec)
  # summary(glm(Y~A+L,data=dat))
  # summary(glm(Y~A,data=dat))
  L <- tibble(L = dat$L)
  res_bb <- psi.hat_linear(Y = dat$Y,A = dat$A,L = c(), subset = NULL, out.bin = TRUE, exp.bin = TRUE, exp.scalar = TRUE,root = "multi")
  result_bb2[i,1] <- exp(res_bb[1])
  result_bb2[i,2] <- exp(res_bb[1] - 1.96*res_bb[2])
  result_bb2[i,3] <- exp(res_bb[1] + 1.96*res_bb[2])
  res_bb_L <- psi.hat_linear(dat$Y,dat$A,L, subset = NULL, out.bin = TRUE, exp.bin = TRUE, exp.scalar = TRUE,root = "multi")
  result_bb_L2[i,1] <- exp(res_bb_L[1])
  result_bb_L2[i,2] <- exp(res_bb_L[1] - 1.96*res_bb_L[2])
  result_bb_L2[i,3] <- exp(res_bb_L[1] + 1.96*res_bb_L[2])
  #random forest
  res_bb_rf <- psi.hat_rf(Y = dat$Y,A = dat$A,L = c(), subset = NULL, out.bin = TRUE, exp.bin = TRUE, exp.scalar = TRUE,root = "multi")
  result_bb_rf2[i,1] <- exp(res_bb_rf[1])
  result_bb_rf2[i,2] <- exp(res_bb_rf[1] - 1.96*res_bb_rf[2])
  result_bb_rf2[i,3] <- exp(res_bb_rf[1] + 1.96*res_bb_rf[2])
  res_bb_rf_L <- psi.hat_rf(dat$Y,dat$A,L_vec, subset = NULL, out.bin = TRUE, exp.bin = TRUE, exp.scalar = TRUE,root = "multi")
  result_bb_rf_L2[i,1] <- exp(res_bb_rf_L[1])
  result_bb_rf_L2[i,2] <- exp(res_bb_rf_L[1]-1.96*res_bb_rf_L[2])
  result_bb_rf_L2[i,3] <- exp(res_bb_rf_L[1]+1.96*res_bb_rf_L[2])
}
t2 <- Sys.time()

df_bb2 <- as.data.frame(result_bb2)
colnames(df_bb2) <- c("point","ci_low","ci_high")
df_bb2 <- df_bb2 %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

df_bb_L2 <- as.data.frame(result_bb_L2)
colnames(df_bb_L2) <- c("point","ci_low","ci_high")
df_bb_L2 <- df_bb_L2 %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

table_bb2 <- tibble(
  noL <- c(sum(df_bb2$contain)/nrow(df_bb2)),
  L <- c(sum(df_bb_L2$contain)/nrow(df_bb_L2))
  )

knitr::kable(table_bb2,
             format = "pipe",
             digits = 3,
             col.names = c("Coverage Rate","Coverage Rate Condition on L"),
             caption = "Result For Binary Outcome to Binary Exposure(GLM)"
             ) 

df_bb_rf2 <- as.data.frame(result_bb_rf2)
colnames(df_bb_rf2) <- c("point","ci_low","ci_high")
df_bb_rf2 <- df_bb_rf2 %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

df_bb_rf_L2 <- as.data.frame(result_bb_rf_L2)
colnames(df_bb_rf_L2) <- c("point","ci_low","ci_high")
df_bb_rf_L2 <- df_bb_rf_L2 %>%
  mutate(contain=ifelse(ci_low < 1 & 1 < ci_high, 1, 0))

table_bb_rf2 <- tibble(
  noL <- c(sum(df_bb_rf2$contain)/nrow(df_bb_rf2)),
  L <- c(sum(df_bb_rf_L2$contain)/nrow(df_bb_rf_L2))
  )

knitr::kable(table_bb_rf2,
             format = "pipe",
             digits = 3,
             col.names = c("Coverage Rate","Coverage Rate Condition on L"),
             caption = "Result For Binary Outcome to Binary Exposure(Random Forest)"
             ) 

p4_2_1 <- df_bb2 %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (GLM without L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))

p4_2_2 <- df_bb_L2 %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (GLM with L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))   

p4_2_3 <- df_bb_rf2 %>% 
  filter(point<2) %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (Random Forest without L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))    

p4_2_4 <- df_bb_rf_L2 %>%
  filter(point<2) %>% 
  ggplot(aes(x=point)) +
  geom_histogram()+
  labs(
    title = "Distribution of Point Estimate (Random Forest with L)",
    x = "Value",
    y = "Frequency",
  )+
  theme(plot.title = element_text(hjust = 0.5))   

(p4_2_1+p4_2_2)/(p4_2_3+p4_2_4)
```



